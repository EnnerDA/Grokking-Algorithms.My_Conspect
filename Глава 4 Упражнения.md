**4.1.** Напишите код для функции sum

```python
from copy import copy

def sum(user_list):
    mod_user_list = copy(user_list)
    if len(mod_user_list) == 1:
        print(mod_user_list[0])
    else:
        mod_user_list[0] += mod_user_list.pop(1)
        sum(mod_user_list) # Внимание !!! РЕКУРСИЯ па-бааам!
```

**4.2.** Напишите рекурсивную функцию для подсчета элементов в списке.
```python

def sum_el(user_list):
    if user_list == []:
        return 0
    else:
        summ = 1 + sum_el(user_list[1:])
        return summ

#Проверка
u_l = [1 ,2, 3, 4]
print(sum_el(u_l))
```

![Как это работает:](https://user-images.githubusercontent.com/116806816/198941991-088e1b2a-73dc-40b2-aede-fe01d353bed0.png)

**4.3.** Найдите наибольшее число в списке.

```python
def biggest_numb(user_list):
    if user_list[1:] == []: # базовый случай, когда в списке 1 элемент
        return user_list[0] #тогда именно его, а не 0 и надо возвразать в качестве наибольшего.
    else:
        if user_list[0] > biggest_numb(user_list[1:]):
            return user_list[0]
        else:
            return biggest_numb(user_list[1:])

#Проверка
from random import randint
u_l = []
for i in range(10):
    u_l.append(randint(1, 100))
print(u_l)
print(biggest_numb(u_l))
```
**4.4.** Помните бинарный поиск из главы 1? Он тоже относится к классу алгоритмов •разделяй и властвуй. Сможете вы ли определить базовый и рекурсивный случай для бинарного поиска?



