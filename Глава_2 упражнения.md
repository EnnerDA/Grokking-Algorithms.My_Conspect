## Упражнение 
**2.1** Вы строите приложение для управления финансами. "Ежедневно вы записываете все свои траты. В конце месяца вы анализируете расходы и вычисляете, сколько денег было потрачено. При работе с данными выполняется множество операций вставки и относительно немного операций чтения. Какую структуру использовать -массив или список? 

**Исходя из предыдущей таблицы  - список предпочтительней.** 

**2.2** Вы пишете приложение для приема заказов от посетителей ресторана. Приложение должно хранить список заказов. Официанты добавляют заказы в список, а повара читают заказы из списка и выполняют их. Заказы образуют очередь: официанты добавляют заказы в конец очереди, а повар берет первый заказ из очереди и начинает готовить. Какую структуру данных вы бы использовали для реализации этой очереди: массив или связанный список?	

**Очевидно, что список пододит лучше.**

**2.3** Как хранить имена пользоватеоей в Facebook?

**Поиск пользователей происходит чаще чем регистрация новых. Вроде уместно использовать массив.**

**2.4** Предположим, вы решили использовать массив для хранения списка пользователей. Какими недостатками обладает массив для выполнения вставки? Допустим, вы используете бинарный поиск для нахождения учетных данных. Что произойдет при добавлении новых пользователей в массив?	

**Каждое добавление пользователя будет занимать O(n). Ну и возможно случится критическая масса новых пользователей, когда для массива не хватит места. Нужно будет всем составом переезжать в какие то расширенные места.**

**2.5** Гибридная система хранения данных списки вложеные в массивы
![изображение](https://user-images.githubusercontent.com/116806816/198538199-650f7ffa-384e-4fde-89da-8f7234d8883c.png)

Будет ли она быстрее или медленнее каждой исходной структуры при поиске и вставке?

**Поиск - сначала мы осуществляем поиск в массиве затем уже в списке. Если изначально было n элементов, то x - количество элементов массива, у - среднее количество элементов списков. n = x\*y, тогда** 

* **Поиск займет O(1) + O(y). Так как y<n, получаем, что поиск стал медленее чем в массиве, но быстрее чем в списке.**

**Вставка - сначала мы осуществляем поиск по массиву а затем вставку в список**

* **Вставка - O(1) + O(1) = O(2). То есть вставка стала в два раза медленее чем в списке, но быстрее чем в массиве.**

**Понятно, что считать длину получившизхся списков одинаковой не вполне верно, и есть крайние случаи когда, допустим, все ячейки массива имеют по одному вложеному значению, а одна ячейки имеет список длиной (n-x+1). В этом случае поиск нужного элемента списка в этой ячейке массива окажется весьма труднее, чем если б это был просто массив. Но этот случай крайний, а автор не даром упомянул FaceBook, считать, чо имена пользователей распределены равномерно по всем буквам, считаю уместно!**



